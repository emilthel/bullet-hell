[gd_scene load_steps=10 format=3 uid="uid://yhxyxski3vhn"]

[sub_resource type="GDScript" id="GDScript_56xki"]
script/source = "extends Node

@onready var level = $Level

func _ready():
	get_tree().paused = true   
	
func _process(delta: float) -> void:
	if Input.is_action_just_pressed(\"pause\"):
		get_tree().paused = not get_tree().paused
		
"

[sub_resource type="GDScript" id="GDScript_gp44b"]
script/source = "extends Area2D
var invincible = false


@export var blood: float = 1
@export var enemy_layer = 2
@export var goal_layer = 4

@onready var level = $\"..\"
@onready var invincibility_timer = $InvincibilityTimer
@onready var bg = $\"../BG\"
@onready var health_bar =  $\"../HealthBar\"

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	global_position = get_global_mouse_position()
	if blood > 1:
		blood = 1
	bg.modulate.a = invincibility_timer.time_left
	health_bar.scale.x = blood
	
func _on_area_entered(area: Area2D) -> void:
	if area.collision_layer == enemy_layer:
		if not invincible:
			blood -= area.damage 
			if blood <= 0:
				get_tree().quit()
			
			invincibility_timer.start()
			invincible = true
			
			
	if area.collision_layer == goal_layer:
		if area.mode == area.SCREEN_CHANGE:
			level.next_screen()
		if area.mode == area.SCRIPT:
			area.on_collected.call()
		area.queue_free()
		blood += area.heal
		
		


func _on_invincibility_timer_timeout() -> void:
	invincible = false
	print(\"timeout\")
"

[sub_resource type="CircleShape2D" id="CircleShape2D_1vguc"]
radius = 23.0868

[sub_resource type="Gradient" id="Gradient_uyvyb"]
interpolation_mode = 1
offsets = PackedFloat32Array(0, 0.5)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 0)
metadata/_snap_enabled = true

[sub_resource type="GradientTexture2D" id="GradientTexture2D_2cts2"]
gradient = SubResource("Gradient_uyvyb")
fill = 1
fill_from = Vector2(0.5, 0.5)

[sub_resource type="GDScript" id="GDScript_xg112"]
script/source = "extends Node2D

@onready var player = $\"../Player\"

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	scale.x = player.blood
"

[sub_resource type="Gradient" id="Gradient_j41ph"]
offsets = PackedFloat32Array(1)
colors = PackedColorArray(1, 1, 1, 1)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_j13k2"]
gradient = SubResource("Gradient_j41ph")
width = 1000
fill_from = Vector2(1, 1)
fill_to = Vector2(1, 1)

[sub_resource type="GDScript" id="GDScript_52fvp"]
script/source = "extends Area2D

var velocity: Vector2 = Vector2(0,0)
var enemy_scene: PackedScene = load(\"res://level_1b/scenes/enemy.tscn\")
var goal_scene: PackedScene = load(\"res://level_1c/Scenes/goal.tscn\")
var log: Array = []
var grid: Dictionary = {}
var is_frame1 = true
var player

@export var log_length: int = 100
@export var count: int = 3
@export var damage = 0.4
@export var angle: float = 0
@export var factor: float = 1
@export var spacing: float = 100

func choice(a: Array):
	return a[randi() % len(a)]

func spawn_child(xn: int, yn: int, scene = enemy_scene):
	var child = scene.instantiate()
	child.position = Vector2(xn,yn)*spacing
	child.velocity = Vector2(0,0)
	child.scale *= 0.9
	if scene == enemy_scene:
		child.damage = damage
	grid[[xn,yn]] = child
	add_child(child)
	return child
	
\"Runs on first frame active\"
func _frame1() -> void:
	player = $\"../../Player\"
	position = player.global_position
	var grid_range = range(-count,count+1)
	for xn in grid_range:
		for yn in grid_range:
			spawn_child(xn,yn)
		
	var xn = choice(grid_range)
	var yn = choice(grid_range)
	#grid[[xn,yn]].queue_free()
	
	grid[[3,3]].queue_free()
	spawn_child(3,3,goal_scene)
	#var goal = goal_scene.instantiate()
	#goal.position = Vector2(xn,yn)*100
	#goal.velocity = Vector2(0,0)
	#goal.scale *= 0.9
	#grid[[xn,yn]] = goal
	#add_child(goal)
	
	grid[[0,0]].queue_free()
	
	for n in range(log_length):
		log.append(player.global_position)
	
			
# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	if is_frame1:
		_frame1()
		is_frame1 = false
	log.append(player.global_position)
	velocity = (log[1]-log[0]).rotated(angle)*factor
	log.remove_at(0)
	position += velocity
"

[node name="PauseManager" type="Node"]
process_mode = 3
script = SubResource("GDScript_56xki")

[node name="Level" type="Node2D" parent="."]
process_mode = 1

[node name="Player" type="Area2D" parent="Level"]
visible = false
position = Vector2(1, -1)
script = SubResource("GDScript_gp44b")

[node name="CollisionShape2D" type="CollisionShape2D" parent="Level/Player"]
shape = SubResource("CircleShape2D_1vguc")

[node name="Sprite2D" type="Sprite2D" parent="Level/Player"]
texture = SubResource("GradientTexture2D_2cts2")

[node name="HealthBar" type="Node2D" parent="Level"]
visible = false
script = SubResource("GDScript_xg112")

[node name="Sprite2D" type="Sprite2D" parent="Level/HealthBar"]
position = Vector2(500, 32)
scale = Vector2(1, 1.006)
texture = SubResource("GradientTexture2D_j13k2")

[node name="Gridder" type="Area2D" parent="Level"]
visible = false
modulate = Color(1, 0, 0, 0.427451)
position = Vector2(1, -1)
script = SubResource("GDScript_52fvp")

[node name="CollisionShape2D" type="CollisionShape2D" parent="Level/Gridder"]
shape = SubResource("CircleShape2D_1vguc")
disabled = true

[node name="SpawnTimer" type="Timer" parent="Level/Gridder"]

[node name="SleepTimer" type="Timer" parent="Level/Gridder"]

[node name="BG" type="Node2D" parent="Level"]
visible = false
script = SubResource("GDScript_xg112")

[node name="Sprite2D" type="Sprite2D" parent="Level/BG"]
modulate = Color(1, 1, 1, 0)
self_modulate = Color(1, 0, 0, 1)
position = Vector2(499.5, 498.404)
scale = Vector2(0.999, 15.5811)
texture = SubResource("GradientTexture2D_j13k2")

[node name="Camera2D" type="Camera2D" parent="Level"]
position = Vector2(-6, 13)

[connection signal="area_entered" from="Level/Player" to="Level/Player" method="_on_area_entered"]
[connection signal="timeout" from="Level/Gridder/SpawnTimer" to="Level/Gridder" method="_on_spawn_timer_timeout"]
[connection signal="timeout" from="Level/Gridder/SleepTimer" to="Level/Gridder" method="_on_sleep_timer_timeout"]
